# System Design Strategy Rules

**更新时间**: 2026-01-23
**策略关键词**: system-design, architecture, best-practices

---
paths: ""
---

## 核心设计原则

### 📚 文档化 vs 自动执行：三层防护体系

**问题场景**: 为什么需要同时在文档中说明规则，又在 Hooks 中自动执行？

**核心洞察**: 文档化（被动教育）和自动执行（主动防护）各有优缺点，最佳实践是两者结合，形成三层防护体系。

#### 三层防护架构

```
┌─────────────────────────────────────────────────────────────┐
│                    三层防护体系                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  第一层：文档教育（project_standards.md）                    │
│  ├─ 角色：规则的"单一事实来源"                              │
│  ├─ 职责：解释"为什么"（原因和背景）                        │
│  ├─ 优势：全面、可搜索、可引用                              │
│  └─ 局限：依赖开发者主动阅读                                │
│                                                             │
│  第二层：自动执行（Hooks: path_validator.py）               │
│  ├─ 角色：规则的"自动执行器"                                │
│  ├─ 职责：执行"怎么做"（自动防止违规）                      │
│  ├─ 优势：实时拦截、零遗漏                                  │
│  └─ 局限：无法解释原因，可能引起困惑                        │
│                                                             │
│  第三层：快速参考（CLAUDE.md）                              │
│  ├─ 角色：开发者的"快速指南"                                │
│  ├─ 职责：提供常见场景的快速决策                            │
│  ├─ 优势：简洁、实用、易查                                  │
│  └─ 局限：不够全面，需要配合第一层使用                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 为什么需要三层？

| 层级 | 解决的问题 | 防护类型 | 适用场景 |
|------|-----------|---------|---------|
| **文档教育** | 开发者不知道规则 | 被动防护 | 学习阶段、规则查询 |
| **自动执行** | 开发者忘记规则 | 主动防护 | 日常开发、紧急修复 |
| **快速参考** | 开发者找不到规则 | 辅助防护 | 快速决策、常见问题 |

#### 具体实现策略

**1. 文档层（project_standards.md）**
```markdown
## 🚨 目录结构强制约束（必须遵守！）

> **自动执行**: 这些约束由 `.claude/hooks/path_validator.py` 自动执行，违规操作将被阻止

### 禁止的目录结构

| ❌ 禁止 | 原因 | ✅ 正确做法 |
|---------|------|------------|
| `tests/` (根目录) | 测试应统一管理 | `main/tests/` |
| `main/backend/docs/` | 文档应统一管理 | `main/docs/` |

### 为什么这样设计？

1. **统一管理**: 所有文档放在 `main/docs/` 便于查找和维护
2. **避免混乱**: 防止文档散落在各个子目录
3. **自动化友好**: 统一路径便于 CI/CD 脚本处理
```

**2. 自动执行层（Hooks）**
```python
# .claude/hooks/path_validator.py

FORBIDDEN_NESTED_PATHS = [
    r"^main/backend/docs/",   # 禁止 main/backend/docs/
    r"^main/frontend/docs/",  # 禁止 main/frontend/docs/
]

def validate_path(path: str) -> tuple[bool, str]:
    """验证路径是否符合规范"""
    for pattern in FORBIDDEN_NESTED_PATHS:
        if re.match(pattern, path):
            return False, f"""
❌ 路径违规: {path}

原因: 文档应统一放在 main/docs/ 目录
正确做法: 将文件移动到 main/docs/ 对应子目录

详细说明: 参考 .claude/project_standards.md 的「目录结构强制约束」章节
"""
    return True, ""
```

**3. 快速参考层（CLAUDE.md）**
```markdown
## 🚨 强制目录结构约束（必须遵守！）

| ❌ 禁止 | ✅ 正确做法 |
|--------|------------|
| `main/backend/docs/` | `main/docs/` |
| `main/frontend/docs/` | `main/docs/` |

**违反约束的惩罚**:
- 任务将被标记为失败
- 需要手动整理目录结构
```

#### 错误提示中的引用链接

当 Hook 拦截违规操作时，错误提示应引用文档位置：

```python
def format_error_message(path: str, rule: str) -> str:
    """格式化错误提示，包含文档引用"""
    return f"""
❌ 路径违规: {path}

违反规则: {rule}

详细说明:
- 参考 .claude/project_standards.md 的「目录结构强制约束」章节
- 参考 CLAUDE.md 的「强制目录结构约束」章节

为什么这样设计？
- 统一管理: 所有文档放在 main/docs/ 便于查找和维护
- 避免混乱: 防止文档散落在各个子目录
- 自动化友好: 统一路径便于 CI/CD 脚本处理
"""
```

#### 最佳实践总结

| 实践 | 说明 |
|------|------|
| **文档先行** | 先在 project_standards.md 中定义规则和原因 |
| **自动执行** | 在 Hooks 中实现自动检查和拦截 |
| **错误引导** | 错误提示中引用文档位置，帮助开发者理解 |
| **快速查询** | 在 CLAUDE.md 中提供简化版规则，便于快速查询 |
| **定期同步** | 当规则变更时，同步更新三层内容 |

#### 适用场景

- ✅ **强制性规则**: 必须遵守的约束（如路径规范、命名约定）
- ✅ **高频错误**: 开发者容易犯的错误（如嵌套目录、错误导入）
- ✅ **自动化检查**: 可以通过代码自动检测的规则
- ❌ **主观判断**: 需要人工判断的规则（如代码质量、设计模式）
- ❌ **复杂逻辑**: 难以用代码表达的规则（如业务逻辑合理性）

#### 注意事项

1. **避免过度自动化**: 不是所有规则都适合自动执行
2. **保持文档权威**: project_standards.md 是唯一事实来源
3. **错误提示友好**: Hook 错误提示应清晰、可操作
4. **定期审查**: 定期检查三层内容是否一致

---

## 聚合经验 (基于多次执行)

### 📊 聚合洞察 (基于 1 次执行)

- **平均奖励**: 9.5/10
- **策略**: system-design
- **描述**: 三层防护体系（文档教育 + 自动执行 + 快速参考）是规则管理的最佳实践
